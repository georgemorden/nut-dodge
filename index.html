<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nut Dodge üêøÔ∏è</title>
  <style>
    :root{--bg-top:#111c22;--bg-bot:#0a1014;--glass:rgba(255,255,255,.10);--glass-strong:rgba(255,255,255,.16);--text:#eaf7ff;--accent:#7df3c6;--accent-2:#ffd166;--shadow:0 10px 30px rgba(0,0,0,.35);--hud-fs:clamp(12px,1.6vw,15px);--hud-pad:clamp(6px,.9vw,10px);--chip-gap:clamp(6px,1vw,10px);--panel-radius:14px;--stage-w:min(92vw,560px)}
    *{box-sizing:border-box}html,body{height:100%;margin:0;color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
    body{background:radial-gradient(1200px 800px at 50% -10%, #1d3644 0%, #12232c 50%, var(--bg-bot) 90%),linear-gradient(180deg, var(--bg-top), var(--bg-bot))}
    .wrap{min-height:100%;display:grid;place-items:start center;padding:24px 0}.stage{width:var(--stage-w)}

    /* HUD uses grid so both panels are equal height */
    .hud{
      width:100%; font-size:var(--hud-fs); margin-bottom:10px;
      display:grid; grid-template-columns: 1fr 220px; gap:12px; align-items:stretch;
    }
    @media (max-width: 520px){
      .hud{ grid-template-columns: 1fr; }
    }

    .panel{backdrop-filter:blur(10px);background:var(--glass);border:1px solid rgba(255,255,255,.18);
      border-radius:var(--panel-radius); padding:var(--hud-pad); box-shadow:var(--shadow);
      display:flex; flex-direction:column; height:100%;
    }

    .stats{flex:1;display:flex;justify-content:space-between;align-items:center;gap:var(--chip-gap)}
    .chip{display:flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;background:var(--glass-strong);border:1px solid rgba(255,255,255,.16);font-weight:700;letter-spacing:.2px}
    .chip .val{font-variant-numeric:tabular-nums}
    .progress{margin-top:6px;height:6px;background:rgba(255,255,255,.10);border-radius:999px;overflow:hidden;border:1px solid rgba(255,255,255,.18)}
    .progress__bar{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),var(--accent-2));transition:width .25s ease}

    .controls{flex:1;display:flex;gap:8px;align-items:center;justify-content:space-between}
    .btn{cursor:pointer;border:1px solid rgba(255,255,255,.18);background:linear-gradient(180deg,rgba(255,255,255,.12),rgba(255,255,255,.06));
      color:var(--text);padding:10px 14px;border-radius:12px;font-weight:800;box-shadow:0 6px 18px rgba(0,0,0,.25);transform:translateZ(0);
      transition:transform .08s ease,background .2s ease,opacity .2s,box-shadow .2s}
    .btn:hover{transform:translateY(-1px);background:linear-gradient(180deg,rgba(255,255,255,.18),rgba(255,255,255,.08));box-shadow:0 10px 22px rgba(0,0,0,.35)}
    .btn:active{transform:translateY(0)}
    .btn--primary{border-color:rgba(125,243,198,.5);box-shadow:0 8px 20px rgba(125,243,198,.22)}
    .btn--danger{border-color:rgba(255,123,123,.5);box-shadow:0 8px 20px rgba(255,123,123,.22)}

    .help{text-align:center;font-size:12px;opacity:.8;margin-top:8px}
    canvas{width:100%;height:auto;background:linear-gradient(#224b59,#1a3440);border:1px solid rgba(255,255,255,.06);border-radius:18px;box-shadow:var(--shadow),inset 0 0 0 1px rgba(255,255,255,.03);display:block}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage">
      <div class="hud" role="region" aria-label="Game HUD">
        <div class="panel panel--stats">
          <div class="stats">
            <div class="chip">‚≠ê Score: <span class="val" id="score">0</span></div>
            <div class="chip">üß± Level: <span class="val" id="level">1</span></div>
            <div class="chip">üéØ Target: <span class="val" id="target">10</span></div>
          </div>
          <div class="progress" aria-label="Level progress">
            <div class="progress__bar" id="bar"></div>
          </div>
        </div>
        <div class="panel panel--controls">
          <div class="controls">
            <button class="btn btn--primary" id="btnStart">‚ñ∂ Start (Space)</button>
            <button class="btn" id="btnPause">‚è∏ P</button>
            <button class="btn btn--danger" id="btnReset">‚Ü∫ R</button>
          </div>
        </div>
      </div>
      <canvas id="game" width="360" height="600"></canvas>
      <div class="help">Controls: ‚óÄ‚ñ∂ / A D move ¬∑ ‚Üë jump ¬∑ Space start ¬∑ P pause ¬∑ R reset</div>
    </div>
  </div>

<script>
// Utility: load external images
function load(src){ return new Promise(r=>{ const i=new Image(); i.onload=()=>r(i); i.src=src; }); }
let sqImg, nutImg;
Promise.all([load('assets/squirrel.png'), load('assets/nut.png')]).then(([s,n])=>{ sqImg=s; nutImg=n; resetGame(); requestAnimationFrame(loop); });

// Canvas & ctx
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const GROUND_H = 40;

// UI
const ui = {
  score: document.getElementById('score'),
  level: document.getElementById('level'),
  target: document.getElementById('target'),
  bar: document.getElementById('bar'),
  btnStart: document.getElementById('btnStart'),
  btnPause: document.getElementById('btnPause'),
  btnReset: document.getElementById('btnReset'),
};

// State
const State = { READY:'ready', PLAYING:'playing', PAUSED:'paused', GAMEOVER:'gameover', WIN:'win' };
let state = State.READY;

// Input
const keys = new Set();
window.addEventListener('keydown', e => {
  if (['ArrowLeft','ArrowRight','ArrowUp',' ','ArrowDown'].includes(e.key)) e.preventDefault();
  keys.add(e.key.toLowerCase());
  if (e.key === ' ' && (state===State.READY || state===State.GAMEOVER || state===State.PAUSED || state===State.WIN)) startGame();
  if (e.key.toLowerCase()==='p') togglePause();
  if (e.key.toLowerCase()==='r') resetGame();
});
window.addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));
ui.btnStart.onclick = startGame; ui.btnPause.onclick = togglePause; ui.btnReset.onclick = resetGame;

// Entities
function makeSquirrel(){
  const w=84, h=96; const groundY = H - GROUND_H - h;
  return { x: W/2 - w/2, y: groundY, w, h, vx:0, vy:0, speed: 208, dir:1, onGround:true };
}
const squirrel = makeSquirrel();

// Levels ‚Äî 10 per level
const MAX_LEVEL = 10;
const perLevel = Array(MAX_LEVEL).fill(10);
const cumulativeTargets = perLevel.map((v,i)=> (i+1)*10);
let level = 1; let nextTarget = cumulativeTargets[0];

// Snow
const SNOW_COUNT = 140; const snow = [];
function seedSnow(){
  snow.length=0;
  for (let i=0;i<SNOW_COUNT;i++){
    snow.push({ x: Math.random()*W, y: Math.random()*H, r: 1 + Math.random()*2,
      vy: 15 + Math.random()*25, ax: (Math.random()*0.6 + 0.2),
      phase: Math.random()*Math.PI*2, vphase: 0.8 + Math.random()*0.8 });
  }
}

// Weather
let snowSpeedMult=1, snowSpeedTarget=1, snowChangeTimer=0;
const WEATHER_INTERVAL=10, TRANSITION_TAU=2;
function pickNewSnowTarget(){ snowSpeedTarget = 0.6 + Math.random()*1.2; }

// Nuts
const nuts = [];
function spawnNut(baseSpeed){
  let w = 36 + Math.random()*10, h = w * 1.25, vy = baseSpeed;
  let spin = 0, varySpeed = false, doSpin = false, windAffect = 0, isGold = false;

  if (level >= 2) doSpin = true;
  if (level >= 3) varySpeed = true;
  if (level >= 4) { doSpin = true; varySpeed = true; }
  if (varySpeed) vy *= 0.85 + Math.random()*0.5;
  if (doSpin) spin = (Math.random()*2 - 1) * 1.8;

  if (level >= 6 && Math.random() < 0.25) { w = 22; h = 28; vy *= 1.5; }
  if (level >= 7 && Math.random() < 0.15) { w = 64; h = 78; vy *= 0.7; }
  if (level >= 8) windAffect = 1;
  if (level >= 9 && Math.random() < 0.12) isGold = true;
  if (level >= 10) vy *= 1.15;

  nuts.push({ x: Math.random()*(W-w), y: -h-10, w, h, vy, rot: 0, spin, windAffect, isGold });
}

// Wind (lvl8+)
let wind=0, windTarget=0, windTimer=0;
const WIND_INTERVAL=6, WIND_MAX=30, WIND_TAU=1.5;

// Timing & difficulty
let last=0, spawnTimer=0, spawnInterval=0.9, fallSpeed=120, score=0, time=0;

// Jump physics
const GRAVITY = 900, JUMP_VY = -480; let jumpPressedLast = false;

// Utils
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function circleRectHit(cx,cy,cr, rx,ry,rw,rh){
  const nnx = Math.max(rx, Math.min(cx, rx+rw));
  const nny = Math.max(ry, Math.min(cy, ry+rh));
  const dx = cx - nnx, dy = cy - nny;
  return (dx*dx + dy*dy) <= (cr*cr);
}

// Game controls
function startGame(){ if (state===State.PLAYING) return; if (state===State.GAMEOVER || state===State.WIN) resetGame(); state = State.PLAYING; }
function togglePause(){ if (state===State.PLAYING) state = State.PAUSED; else if (state===State.PAUSED) state = State.PLAYING; }
function resetGame(){ state=State.READY; nuts.length=0; spawnTimer=0; last=0; spawnInterval=0.9; fallSpeed=120; score=0; level = 1; nextTarget = cumulativeTargets[0]; Object.assign(squirrel, makeSquirrel()); seedSnow(); snowSpeedMult=1; snowSpeedTarget=1; snowChangeTimer=0; wind=0; windTarget=0; windTimer=0; time=0; draw(0); updateHUD(); }
function updateHUD(){
  ui.score.textContent = score;
  ui.level.textContent = level;
  ui.target.textContent = nextTarget;
  const prevTarget = level>1 ? cumulativeTargets[level-2] : 0;
  const prog = Math.max(0, Math.min(1, (score - prevTarget) / (nextTarget - prevTarget)));
  ui.bar.style.width = (prog*100).toFixed(1) + "%";
}

// Loop
function loop(ts){
  if (!last) last = ts;
  const dt = Math.min(0.033, (ts-last)/1000);
  last = ts;
  time += dt; // animation clock

  if (state===State.PLAYING) update(dt); else updateSnow(dt);
  draw(dt);
  requestAnimationFrame(loop);
}

function update(dt){
  // weather
  snowChangeTimer += dt; if (snowChangeTimer >= WEATHER_INTERVAL) { snowChangeTimer = 0; pickNewSnowTarget(); }
  const lerp = 1 - Math.exp(-dt / TRANSITION_TAU); snowSpeedMult += (snowSpeedTarget - snowSpeedMult) * lerp;

  // wind
  windTimer += dt; if (windTimer >= WIND_INTERVAL) { windTimer = 0; windTarget = (Math.random()*2 - 1) * WIND_MAX; }
  const wlerp = 1 - Math.exp(-dt / WIND_TAU); wind += (windTarget - wind) * wlerp;

  // input
  const left = keys.has('arrowleft') || keys.has('a');
  const right = keys.has('arrowright') || keys.has('d');
  squirrel.vx = (right - left) * squirrel.speed;

  // Face movement direction
  if (right && !left) squirrel.dir = 1;
  else if (left && !right) squirrel.dir = -1;

  const jumpNow = keys.has('arrowup');
  if (jumpNow && !jumpPressedLast && squirrel.onGround) { squirrel.vy = JUMP_VY; squirrel.onGround = false; }
  jumpPressedLast = jumpNow;

  // physics
  squirrel.x = clamp(squirrel.x + squirrel.vx * dt, 4, W - squirrel.w - 4);
  squirrel.y += squirrel.vy * dt;
  if (!squirrel.onGround) squirrel.vy += GRAVITY * dt;

  // ground
  const groundY = H - GROUND_H - squirrel.h;
  if (squirrel.y >= groundY) { squirrel.y = groundY; squirrel.vy = 0; squirrel.onGround = true; }

  // spawn
  spawnTimer += dt;
  const effInterval = Math.max(0.35, spawnInterval * (level>=10 ? 0.8 : 1));
  if (spawnTimer >= effInterval) { spawnTimer = 0; spawnNut(fallSpeed); if (level >= 5 && Math.random() < 0.4) spawnNut(fallSpeed); }

  // collisions & scoring
  const insetX = squirrel.w*0.18, insetY = squirrel.h*0.22;
  const rx = squirrel.x + insetX, ry = squirrel.y + insetY;
  const rw = squirrel.w - insetX*2, rh = squirrel.h - insetY*2;

  for (let i = nuts.length-1; i>=0; i--) {
    const n = nuts[i];
    if (n.windAffect) n.x += wind * dt;
    if (n.spin) n.rot = (n.rot || 0) + n.spin * dt;
    n.y += n.vy * dt;

    const cx = n.x + n.w/2, cy = n.y + n.h*0.5;
    const cr = Math.min(n.w,n.h)*0.38;
    if (circleRectHit(cx, cy, cr, rx, ry, rw, rh)) { state = State.GAMEOVER; break; }

    if (n.y > H + 60) { score++; nuts.splice(i,1); continue; }
    if (n.x < -80 || n.x > W+80) { nuts.splice(i,1); continue; }
  }

  // levels
  if (score >= nextTarget) {
    if (level >= MAX_LEVEL) { state = State.WIN; }
    else { level++; nextTarget = cumulativeTargets[level-1]; toast('LEVEL UP! üöÄ'); }
  }

  updateSnow(dt);
  updateHUD();
}

function updateSnow(dt){
  for (const s of snow) { s.phase += s.vphase * dt; const drift = Math.sin(s.phase) * s.ax;
    s.y += (s.vy * snowSpeedMult) * dt; s.x += drift * dt;
    if (s.y > H + 2) { s.y = -4; s.x = Math.random()*W; s.vy = 15 + Math.random()*25; s.ax = (Math.random()*0.6 + 0.2); s.vphase = 0.8 + Math.random()*0.8; s.r = 1 + Math.random()*2; }
    if (s.x < -10) s.x = W + 8; if (s.x > W + 10) s.x = -8; }
}

// Rendering
let toastTimer = 0, toastText = '';
function toast(t){ toastText = t; toastTimer = 1.2; }
function draw(dt){
  ctx.clearRect(0,0,W,H);
  // vignette glow
  const grd = ctx.createRadialGradient(W/2, 80, 30, W/2, 80, 300);
  grd.addColorStop(0, 'rgba(125,243,198,0.12)'); grd.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grd; ctx.fillRect(0,0,W,H);

  // ground
  ctx.fillStyle = '#1e4d2b'; ctx.fillRect(0, H-GROUND_H, W, GROUND_H);
  ctx.fillStyle = '#2e7d32'; ctx.fillRect(0, H-GROUND_H+6, W, GROUND_H-6);

  // snow
  ctx.globalAlpha = 0.9; ctx.fillStyle = '#ffffff';
  for (const s of snow) { ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill(); }
  ctx.globalAlpha = 1;

  if (state===State.READY){ drawCenterText('Nut Dodge üêøÔ∏è', W/2, 160, 28, '#ffffff'); drawCenterText('10 nuts per level ¬∑ ‚Üë to jump\nSpace to start', W/2, 210, 14, '#f1fff1'); }

  // nuts
  for (const n of nuts) drawNut(n);
  // player
  drawSquirrel();

  if (toastTimer > 0) { toastTimer -= (dt || 0.016); ctx.globalAlpha = Math.max(0, Math.min(1, toastTimer)); drawCenterText(toastText, W/2, 90, 18, '#fffbe6'); ctx.globalAlpha = 1; }

  if (state===State.GAMEOVER){ ctx.globalAlpha = 0.9; ctx.fillStyle = 'rgba(0,0,0,.4)'; ctx.fillRect(20, H/2-80, W-40, 140); ctx.globalAlpha = 1;
    drawCenterText('Bonked! üí•', W/2, H/2-30, 22, '#ffe9e6'); drawCenterText(`Nuts dodged: ${score}`, W/2, H/2+2, 16, '#fff7'); drawCenterText('Press Space to retry', W/2, H/2+36, 14, '#dfeedd'); }
  if (state===State.WIN){ ctx.globalAlpha = 0.9; ctx.fillStyle = 'rgba(0,0,0,.4)'; ctx.fillRect(20, H/2-90, W-40, 160); ctx.globalAlpha = 1;
    drawCenterText('YOU WIN! üéâ', W/2, H/2-36, 24, '#eaffea'); drawCenterText(`Total dodged: ${score}`, W/2, H/2-2, 16, '#ffffff'); drawCenterText('Press Space to play again', W/2, H/2+34, 14, '#dfeedd'); }
}

function drawCenterText(txt, x, y, size, color){
  ctx.fillStyle = color; ctx.font = `800 ${size}px ui-sans-serif, -apple-system, Segoe UI, Roboto`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  const lines = String(txt).split('\n'); for (let i=0;i<lines.length;i++) ctx.fillText(lines[i], x, y + i * (size + 6));
}

function drawSquirrel(){
  if (!sqImg) return;
  const s = squirrel;

  // Subtle movement: bob + lean when moving
  const speed = Math.abs(s.vx);
  const bob = (speed > 10 ? Math.sin(time * 8) * 1.5 : Math.sin(time * 2) * 0.6);
  const lean = (s.vx / s.speed) * 0.15; // small rotation

  ctx.save();

  // Mirror when facing left
  if (s.dir === -1) {
    ctx.translate(s.x + s.w, s.y + bob + s.h/2);
    ctx.scale(-1, 1);
  } else {
    ctx.translate(s.x, s.y + bob + s.h/2);
  }

  // Gentle lean
  ctx.translate(s.w/2, 0);
  ctx.rotate(lean);
  ctx.translate(-s.w/2, -s.h/2);

  ctx.drawImage(sqImg, 0, 0, s.w, s.h);
  ctx.restore();
}

function drawNut(n){
  if (!nutImg) return; ctx.save();
  if (n.isGold) { ctx.globalAlpha = 0.75; ctx.fillStyle = '#ffe066'; ctx.beginPath(); ctx.ellipse(n.x+n.w/2, n.y+n.h/2, n.w*0.55, n.h*0.55, 0, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; }
  if (n.spin) { ctx.translate(n.x+n.w/2, n.y+n.h/2); ctx.rotate(n.rot || 0); ctx.drawImage(nutImg, -n.w/2, -n.h/2, n.w, n.h); }
  else { ctx.drawImage(nutImg, n.x, n.y, n.w, n.h); }
  ctx.restore();
}

// Boot
seedSnow();
resetGame();
requestAnimationFrame(loop);
</script>
</body>
</html>
